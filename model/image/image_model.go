// Code generated by go-dbmodel-gen. DO NOT EDIT.
// versions:
// 	go-dbmodel-gen v1.0.2
// nolint
package image

import (
	"fmt"
	"time"

	"ginTemplate/model/common"
)

/** JSGEN({type: "model", paged: true})
CREATE TABLE tbImage (
	id int(10) NOT NULL AUTO_INCREMENT  COMMENT 'ID',
    imageName varchar(256) NOT NULL DEFAULT '' COMMENT '图片名称',
    size int(10) NOT NULL DEFAULT 0 COMMENT '图片大小',
    contentType varchar(64) NOT NULL DEFAULT '' COMMENT 'contentType',
    image blob NOT NULL COMMENT '图片二进制',
	hashCode varchar(256) NOT NULL COMMENT '图片hash值',
    creator varchar(64) NOT NULL DEFAULT '' COMMENT '创建者',
    createTime datetime NOT NULL COMMENT '创建时间@now',
	PRIMARY KEY (id)
);
JSGEN **/

var _ = time.Now

// ImageConnection Image连接类型
type ImageConnection func() common.DBConnect

// DefaultImageConnection DefaultImage默认连接
var DefaultImageConnection ImageConnection

// Image Image值类型
type Image struct {
  ID int `json:"id"`
  ImageName string `json:"imageName"`
  Size int `json:"size"`
  ContentType string `json:"contentType"`
  Image []byte `json:"image"`
  HashCode string `json:"hashCode"`
  Creator string `json:"creator"`
  CreateTime time.Time `json:"createTime"`
}

// Add 插入Image
func (c ImageConnection) Add(model *Image) (int64, error) {
    sqlStr := "INSERT INTO `tbImage` (`imageName`, `size`, `contentType`, `image`, `hashCode`, `creator`, `createTime`) VALUES(?, ?, ?, ?, ?, ?, now())"
    result, err := c().Exec(sqlStr, model.ImageName, model.Size, model.ContentType, model.Image, model.HashCode, model.Creator)
    if err != nil {
        return 0, err
    } 
    
    return result.LastInsertId()
}

// AddImage 插入Image
func AddImage(model *Image) (int64, error) {
    return DefaultImageConnection.Add(model)
}

// Find 查询Image
func (c ImageConnection) Find(condition string, args ...interface{}) ([]*Image, error) {
    sqlStr := "SELECT `id`, `imageName`, `size`, `contentType`, `image`, `hashCode`, `creator`, `createTime` FROM `tbImage`"
    if len(condition) > 0 {
        sqlStr = sqlStr + " WHERE " + condition
    }
    results := make([]*Image, 0)

	stmt, err := c().Prepare(sqlStr)
	if err != nil {
		return results, err
	}
	defer stmt.Close()
	rows, err := stmt.Query(args...)
    if err != nil {
        return results, err
    } 
    
        defer rows.Close()
        for rows.Next() {
            model := Image{}
            values := []interface{}{
              new(interface{}),
              new(interface{}),
              new(interface{}),
              new(interface{}),
              new(interface{}),
              new(interface{}),
              new(interface{}),
              new(interface{}),
            }
            rows.Scan(values...)
            if *(values[0].(*interface{})) != nil {
                tmp := int((*(values[0].(*interface{}))).(int64))
                model.ID = tmp
            }
            if *(values[1].(*interface{})) != nil {
                tmp := string((*(values[1].(*interface{}))).([]uint8))
                model.ImageName = tmp
            }
            if *(values[2].(*interface{})) != nil {
                tmp := int((*(values[2].(*interface{}))).(int64))
                model.Size = tmp
            }
            if *(values[3].(*interface{})) != nil {
                tmp := string((*(values[3].(*interface{}))).([]uint8))
                model.ContentType = tmp
            }
            if *(values[4].(*interface{})) != nil {
                tmp := (*(values[4].(*interface{}))).([]byte)
                model.Image = tmp
            }
            if *(values[5].(*interface{})) != nil {
                tmp := string((*(values[5].(*interface{}))).([]uint8))
                model.HashCode = tmp
            }
            if *(values[6].(*interface{})) != nil {
                tmp := string((*(values[6].(*interface{}))).([]uint8))
                model.Creator = tmp
            }
            if *(values[7].(*interface{})) != nil {
                tmp := (*(values[7].(*interface{}))).(time.Time)
                model.CreateTime = tmp
            }
            results = append(results, &model)
        }
    return results, nil
}

// FindImage 查询Image
func FindImage(condition string, args ...interface{}) ([]*Image, error) {
    return DefaultImageConnection.Find(condition, args...)
}
// PagedQuery 分页查询Image
func (c ImageConnection) PagedQuery(condition string, pageSize uint, page uint, args ...interface{}) (totalCount uint, rows []*Image, err error) {
	sqlStr := "SELECT COUNT(1) as cnt FROM `tbImage`"
	if len(condition) > 0 {
		sqlStr = sqlStr + " WHERE " + condition
	}

	cr := c().QueryRow(sqlStr, args...)

	err = cr.Scan(&totalCount)
	if err != nil {
		return 0, nil, err
	}
	if page > 0 {
		page = page - 1
	}
	offset := page * pageSize
	if totalCount <= offset {
		return totalCount, []*Image{}, nil
	}

	if len(condition) == 0 {
		condition = fmt.Sprintf("1=1")
	}
	condition = condition + fmt.Sprintf(" LIMIT %d OFFSET %d", pageSize, offset)
	rows, err = c.Find(condition, args...)
	return
}

// ImagePagedQuery 分页查询Image
func ImagePagedQuery(condition string, pageSize uint, page uint, args ...interface{}) (totalCount uint, rows []*Image, err error) {
	return DefaultImageConnection.PagedQuery(condition, pageSize, page, args...)
}

// Get 获取Image
func (c ImageConnection) Get(condition string, args ...interface{}) (*Image, error) {
    results, err := c.Find(condition, args...)

    if err != nil {
        return nil, err
    } 
    
    if len(results) > 0 {
        return results[0], nil
    } 
        
    return nil, nil
}


// GetImage 获取Image
func GetImage(condition string, args ...interface{}) (*Image, error) {
    return DefaultImageConnection.Get(condition, args...)
}

// Update 更新Image
func (c ImageConnection) Update(model *Image) (int64, error) {
    sqlStr := "UPDATE `tbImage` SET `imageName` = ?, `size` = ?, `contentType` = ?, `image` = ?, `hashCode` = ?, `creator` = ? WHERE `id` = ?"
    result, err := c().Exec(sqlStr, model.ImageName, model.Size, model.ContentType, model.Image, model.HashCode, model.Creator, model.ID)
    if err != nil {
        return 0, err
    }
    return result.RowsAffected()
}

// UpdateImage 更新Image
func UpdateImage(model *Image) (int64, error) {
    return DefaultImageConnection.Update(model)
}
